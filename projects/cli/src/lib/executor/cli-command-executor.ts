import {
    ICliExecutionContext,
    ICliCommandProcessor,
    CliProcessCommand,
    getRightOfWord,
    getParameterValue,
    ICliCommandExecutorService,
    CancellablePromise,
    CliForegroundColor,
    ICliCommandProcessorRegistry,
} from '@qodalis/cli-core';
import { CommandParser, CommandPart } from '../parsers';
import { CliExecutionProcess } from '../context/cli-execution-process';
import { CliArgsParser } from '../parsers/args-parser';
import { ProcessExitedError } from '../errors';
import { CliCommandExecutionContext } from '../context/cli-command-execution-context';
import { CliAliasCommandProcessor } from '../processors';

/**
 * Extended execution context interface used internally by the command executor.
 * The concrete implementation (e.g. CliExecutionContext in angular-cli) provides these.
 */
export interface ICliExecutionHost extends ICliExecutionContext {
    contextProcessor?: ICliCommandProcessor;
    abort?(): void;
}

export class CliCommandExecutor implements ICliCommandExecutorService {
    private commandParser: CommandParser = new CommandParser();

    constructor(protected readonly registry: ICliCommandProcessorRegistry) {}

    public async executeCommand(
        command: string,
        context: ICliExecutionContext,
    ): Promise<void> {
        const parts = CommandParser.splitByOperators(command);

        let rootContext: ICliExecutionHost;
        if (context instanceof CliCommandExecutionContext) {
            rootContext = context.context as ICliExecutionHost;
        } else {
            rootContext = context as ICliExecutionHost;
        }

        // Track the last *executed* command's success â€” skipped commands don't change this.
        let lastExitSuccess = true;
        // Whether the next command part should be executed.
        let shouldRunNext = true;
        // Data flowing through the pipeline â€” explicitly tracked so it survives
        // process.start() resets and failed commands.
        let pipelineData: any = undefined;

        for (let i = 0; i < parts.length; i++) {
            const part = parts[i];

            if (part.type === '&&') {
                shouldRunNext = lastExitSuccess;
                continue;
            } else if (part.type === '||') {
                shouldRunNext = !lastExitSuccess;
                continue;
            } else if (part.type === '|') {
                // Pipe: always run next command with previous output
                shouldRunNext = true;
                continue;
            } else if (part.type === '>>') {
                const nextPart = parts[i + 1];
                i++;
                if (!nextPart || nextPart.type !== 'command') {
                    context.writer.writeError('Missing file path after >>');
                    lastExitSuccess = false;
                    continue;
                }
                if (shouldRunNext) {
                    await this.appendOutputToFile(nextPart.value, context);
                    // Data was consumed by the redirect â€” clear it
                    pipelineData = undefined;
                }
                continue;
            }

            // Command part â€” only execute if shouldRunNext
            if (!shouldRunNext) {
                // Skipped: do NOT update lastExitSuccess or pipelineData
                continue;
            }

            try {
                await this.executeSingleCommand(
                    part.value,
                    pipelineData,
                    rootContext,
                );

                lastExitSuccess =
                    context.process.exitCode === undefined ||
                    context.process.exitCode === 0;

                // Capture output for the next command in the chain
                pipelineData = context.process.data;
            } catch (e) {
                lastExitSuccess = false;
                // Failed command didn't produce usable output â€” preserve
                // whatever data was available before the failure so that
                // a >> redirect after || can still access it.

                context.writer.writeError(`Command ${part.value} failed: ${e}`);
            }

            // Default: next command runs unless an operator says otherwise
            shouldRunNext = true;
        }
    }

    private async appendOutputToFile(
        filePath: string,
        context: ICliExecutionContext,
    ): Promise<void> {
        const FS_TOKEN = 'cli-file-system-service';

        let fs: any;
        try {
            fs = context.services.get(FS_TOKEN);
        } catch {
            context.writer.writeError(
                '>> redirect requires @qodalis/cli-files plugin',
            );
            return;
        }

        const output = context.process.data;
        if (output === undefined || output === null) {
            return;
        }

        try {
            const resolved = fs.resolvePath(filePath.trim());
            const content = typeof output === 'string' ? output : JSON.stringify(output);
            if (fs.exists(resolved)) {
                fs.writeFile(resolved, content, true); // append
            } else {
                fs.createFile(resolved, content);
            }
            await fs.persist();
        } catch (e: any) {
            context.writer.writeError(`>> failed: ${e.message || e}`);
        }
    }

    private async executeSingleCommand(
        command: string,
        data: any | undefined,
        context: ICliExecutionHost,
    ): Promise<void> {
        const process = context.process as CliExecutionProcess;

        process.start();

        const { commandName, args: parsedArgs } =
            this.commandParser.parse(command);

        const [mainCommand, ...other] = commandName.split(' ');

        const chainCommands = other.map((c) => c.toLowerCase());

        const searchableProcessors = context.contextProcessor
            ? (context.contextProcessor.processors ?? [])
            : this.registry.processors;

        const processor = this.registry.findProcessorInCollection(
            mainCommand,
            chainCommands,
            searchableProcessors,
        );

        if (!processor) {
            const aliasProcessor = this.registry.findProcessor(
                'alias',
                [],
            ) as CliAliasCommandProcessor | undefined;
            const aliases = aliasProcessor?.userAliases ?? {};

            if (aliases[mainCommand]) {
                return await this.executeSingleCommand(aliases[mainCommand], data, context);
            }

            context.writer.writeError(
                `Command not found: ${context.writer.wrapInColor(commandName, CliForegroundColor.Cyan)}`,
            );

            context.writer.writeln();

            context.writer.writeInfo(
                `ðŸ’¡ Type ${context.writer.wrapInColor('help', CliForegroundColor.Cyan)} for a list of available commands`,
            );
            context.writer.writeInfo(
                `ðŸ“¦ Use ${context.writer.wrapInColor('pkg add <name>', CliForegroundColor.Cyan)} to install additional commands`,
            );

            context.process.exit(-1, {
                silent: true,
            });

            return;
        }

        const args = CliArgsParser.convertToRecord(parsedArgs, processor);

        const commandToProcess: CliProcessCommand = {
            command: commandName,
            chainCommands: chainCommands,
            rawCommand: command,
            args: args,
            data: data,
        };

        if (this.versionRequested(context, processor, args)) {
            process.end();
            return;
        }

        if (await this.helpRequested(commandToProcess, context)) {
            process.end();
            return;
        }

        if (this.setContextProcessorRequested(context, processor, args)) {
            process.end();
            return;
        }

        if (!this.validateBeforeExecution(context, processor, args)) {
            process.end();
            return;
        }

        const value =
            processor.allowUnlistedCommands || processor.valueRequired
                ? getRightOfWord(commandName, processor.command)
                : undefined;

        commandToProcess.value = value;

        const missingValue = processor.valueRequired && !value;

        if (missingValue) {
            context.writer.writeError(
                `Value required: ${context.writer.wrapInColor(`${commandName} <value>`, CliForegroundColor.Cyan)}`,
            );

            context.process.exit(-1);

            return;
        }

        if (processor.validateBeforeExecution) {
            const validationResult = processor.validateBeforeExecution(
                commandToProcess,
                context,
            );

            if (validationResult.valid === false) {
                context.writer.writeError(
                    validationResult?.message ||
                        'An error occurred while validating the command.',
                );

                context.process.exit(-1);

                return;
            }
        }

        let cancellable: CancellablePromise<void> = null!;

        const commandContext = new CliCommandExecutionContext(
            context,
            processor,
        );

        try {
            const hooks = processor.hooks ?? [];

            for (const hook of hooks.filter((h) => h.when === 'before')) {
                await hook.execute(commandContext);
            }

            cancellable = new CancellablePromise<void>(
                async (resolve, reject) => {
                    processor
                        .processCommand(commandToProcess, commandContext)
                        .then(() => {
                            resolve();
                        })
                        .catch((e) => {
                            reject(e);
                        });
                },
            );

            await cancellable.execute();

            for (const hook of hooks.filter((h) => h.when === 'after')) {
                await hook.execute(commandContext);
            }

            process.end();
        } catch (e) {
            context.spinner?.hide();

            if (e instanceof ProcessExitedError) {
                cancellable?.cancel();

                context.abort?.();

                if (e.code !== 0) {
                    context.writer.writeError(
                        `Process exited with code ${e.code}`,
                    );
                } else {
                    context.writer.writeInfo(
                        'Process exited successfully with code 0',
                    );
                }
            } else {
                context.writer.writeError(`Error executing command: ${e}`);
                context.process.exit(-1);
            }
        }
    }

    public async showHelp(
        command: CliProcessCommand,
        context: ICliExecutionContext,
    ): Promise<void> {
        try {
            await this.executeCommand('help ' + command.rawCommand, context);
        } catch (e) {
            context.writer.writeError(`Error executing command: ${e}`);
        }
    }

    private versionRequested(
        context: ICliExecutionContext,
        processor: ICliCommandProcessor,
        args: Record<string, any>,
    ): boolean {
        if (args['v'] || args['version']) {
            context.writer.writeln(
                `${context.writer.wrapInColor(processor.version || '1.0.0', CliForegroundColor.Cyan)}`,
            );
            return true;
        }

        return false;
    }

    private setContextProcessorRequested(
        context: ICliExecutionContext,
        processor: ICliCommandProcessor,
        args: Record<string, any>,
    ): boolean {
        if (args['context']) {
            context.setContextProcessor(processor);
            return true;
        }

        return false;
    }

    private async helpRequested(
        commandToProcess: CliProcessCommand,
        context: ICliExecutionContext,
    ): Promise<boolean> {
        if (commandToProcess.command?.startsWith('help')) {
            return false;
        }

        if (commandToProcess.args['h'] || commandToProcess.args['help']) {
            await this.showHelp(commandToProcess, context);

            return true;
        }

        return false;
    }

    /**
     * Validates the command arguments before execution.
     * @param context The current CLI execution context.
     * @param processor The processor to validate.
     * @param args The command arguments.
     * @returns True if the arguments are valid, false otherwise.
     */
    private validateBeforeExecution(
        context: ICliExecutionContext,
        processor: ICliCommandProcessor,
        args: Record<string, any>,
    ): boolean {
        // Check for required parameters
        if (processor.parameters?.some((p) => p.required)) {
            const missingParams = processor.parameters?.filter(
                (p) =>
                    p.required &&
                    !args[p.name] &&
                    !p.aliases?.some((a) => args[a]),
            );

            if (missingParams?.length) {
                context.writer.writeError(
                    `Missing required parameters: ${missingParams
                        .map((p) => context.writer.wrapInColor(`--${p.name}`, CliForegroundColor.Cyan))
                        .join(', ')}`,
                );

                return false;
            }
        }

        // Check for parameter validation
        const parametersToValidate =
            processor.parameters
                ?.filter((x) => x.validator)
                ?.map((p) => ({
                    parameter: p,
                    value: getParameterValue(p, args),
                }))
                ?.filter((p) => p.value) ?? [];

        if (parametersToValidate.length > 0) {
            const invalidParams = parametersToValidate
                .map((p) => ({
                    name: p.parameter.name,
                    result: p.parameter.validator!(p.value),
                }))
                .filter((p) => !p.result.valid)
                .map((p) => ({
                    name: p.name,
                    message: p.result.message,
                }));

            if (invalidParams?.length) {
                context.writer.writeError('Invalid parameters:');

                invalidParams.forEach((p, index) => {
                    context.writer.writeln(
                        `  ${index + 1}. ${context.writer.wrapInColor(`--${p.name}`, CliForegroundColor.Cyan)} = "${args[p.name]}" â†’ ${p.message}`,
                    );
                });

                return false;
            }
        }

        return true;
    }
}
